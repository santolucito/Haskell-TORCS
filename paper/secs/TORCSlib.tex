\section{\ourLib}
We provide an open source library, \ourLib\footnote{\url{https://github.com/santolucito/Haskell-TORCS}}, for interfacing Haskell FRP programs to TORCS, The Open Racing Car Simulator, which is an existing open source vehicle simulator~\cite{torcs}.
We developed a library to program controllers for autonomous vehicles using FRP, and connecting these controllers to the TORCS~\cite{torcs} vehicle simulator.
This library, which we call \mbox{\ourLib}, uses Yampa as the core FRP library, though its structure can easily be adapted to any other Haskell FRP library.

\subsection{Implementation} 

TORCS uses a specialized physics engine for vehicle simulations. 
The next planned release of TORCS is slated to include levels of detail such a variable tire traction based on environmental temperature, tire temperature, tire wear, and surface conditions\footnote{http://www.berniw.org/trb/forum/showthread.php?topicid=4744}.
Controllers can be programmed in C or \CC directly into the source code of TORCS.
When TORCS is used in the Simulated Car Racing Championship competition~\cite{SCRC}, each car is controlled via a socket that sends the sensor data from the vehicle and receives and processes the driving commands.

As backend, we use the FRP library Yampa~\cite{courtney2003yampa}. 
As a convenient result of to the unique programming style provided by Haskell and its purity, any other FRP library is suited as well, with respect to purely syntactic adaptions.
With the assistance of FRP, we create the  vehicle controller in a principled way that allows users to manipulated sensor data in a transparent and well structured environment.

In addition to the functionality realized in past TORCS bindings, we have also augmented \ourLib with the ability to test vehicle platooning algorithms that utilize cross-vehicle communications.
The communication channels are realized via a hash map, using the \texttt{Data.Map} interface, from vehicle identifiers to messages.
Each vehicle is given write permissions to their unique channel, where all other vehicles have read-only permissions.
The access is mutually exclusive, which is ensured by Haskell's \texttt{MVar} implementation, a threadsafe shared memory library. 

\subsection{Basics}

To interface with \ourLib, a user must implement a controller that will process the \texttt{CarState}, which contains all the data available from the sensors.
The controller should then output a \texttt{DriveState}, which contains all the data for controlling the vehicle.
This transformation is succinctly described as the now familiar \textit{signal function}.
The core functionality of \ourLib is captured in the function \texttt{startDriver}, which will launch a controller in the simulator.
This function automatically connects a \texttt{Driver} to TORCS, which results in continuous \texttt{IO()} actions, the output type of this function.

\vspace{0.2em}
\begin{lstlisting}
  type Driver = SF CarState DriveState
  startDriver :: Driver -> IO ()
\end{lstlisting}
\vspace{0.2em}

\noindent The sensor and output data structures contain all the typical data available in an autonomously controlled vehicle.
\texttt{CarState} includes fields like \texttt{rpm} to monitor the engine, or \texttt{track} to simulate an array of LiDAR sensors oriented to the front of the vehicle.
\texttt{DriveState} includes fields like \texttt{accel} to control gas pedal, or \texttt{steering} to control the angle of the steering wheel.
A full description of the interface is available in the Simulated Car Racing Competition Manual~\cite{SCRCManual}. 

\subsection{Case Study : Driving}

As a demonstration of the \ourLib library in use, we present a case study on a simple controller for a car on an empty race track, as shown in Listing~\ref{lst:driver}. 
The code is complete and immediately executable as-is together with an installation of TORCS.
Our controller successfully navigates, with some speed and finesse, a vehicle in track, as shown in Fig.~\ref{fig:race}.
The controller uses \texttt{ArrowLoop} to keep track of the current gear of the car.
Although the gear is available as sensor data, it is illustrative to keep track locally of this state.
In general, the \texttt{ArrowLoop} can be used to maintain any state that may be of interest in a future processing step.
Additionally, notice all of the data manipulation functions are pure, and lifted via the predefined function~\texttt{arr}.
One major advantage of FRP is this separation of dependency flow and data level manipulation. 

This abstraction makes it possible to easily reason about each of the components without worrying about confounding factors from the other.
For example, if a programmer wants to verify that the steering control is correct, it is semantically guaranteed that the only function that must be checked is \texttt{steering}.
Because of Haskell's purity, this is the only place where the steering value may be changed. This significantly reducing the complexity of verification or bug tracking in case of an error.

\begin{lstlisting}[float,floatplacement=TR,caption=A complete basic controller in Yampa, label=lst:driver]
{-# LANGUAGE Arrows, MultiWayIf, RecordWildCards #-}
module TORCS.Example where
import TORCS.Connect
import TORCS.Types

main = startDriver myDriver

myDriver :: Driver
myDriver = proc CarState{..}  -> do
  rec 
    oldG <- iPre 0 -< g
    g <- arr shifting -< (rpm, oldG)
    s <- arr steering -< (angle, trackPos)
    a <- arr gas -< (speedX, s)
  returnA -< defaultDriveState {accel = a, gear = g, steer = s}

shifting :: (Double, Int) -> Int
shifting (rpm, g) = if 
  | rpm > 6000 -> min 6 (g + 1)
  | rpm < 3000 -> max 1 (g - 1)
  | otherwise  -> g
 
steering :: (Double, Double) -> Double
steering (spd, trackPos) = let
  turns = spd * 14 / pi
  centering = turns - (trackPos * 0.1)
  clip x = max (-1) (min x 1)
 in
  clip centering

gas :: (Double, Double) -> Double
gas (speed, steer) = 
  if speed < (100 - (steer * 50)) then 1 else 0
\end{lstlisting}
% removed "targetspeed=100" and replaced it directly by the value. 
% There is no need here to spend this extra line.

\subsection{Case Study : Communication for Platoons}

Thanks to functional language's exceptional support for parallelism, controlling multiple vehicles in a multi-threaded environment is exceedingly simple. 
In our library API, the user simply uses \texttt{startDrivers} rather than \texttt{startDriver}, and passes a list of \texttt{Driver} signal functions ``driving'' together.
In this way, we easily let various implementations race against each other, or build a vehicle platooning controller.
In the latter, the user can even extend the implementation to simulate communication between the vehicles.

Our library already provides a simple interface for simulating communication between vehicles.
In order to broadcast a message to the other vehicles in the simulation, the controller simply broadcasts a message via the \texttt{broadcast} field of \texttt{DriveState}.
That message is then broadcast to all other vehicles as soon as possible, and received in the \texttt{communication} field of the input \texttt{CarState}.

Users are now able to implement functions, as in Listing~\ref{lst:platoon}, to communicate between vehicles.
In this example, a vehicle checks if a collision is imminent, and can request for the other cars in the platoon to go faster and move out of the way.
Every vehicle also checks if any other car has requested for the platoon to speed up, and will adjust its own speed accordingly.
These functions can be added to a controller, like the one in Listing~\ref{lst:driver}, with little effort.
\begin{lstlisting}[float,floatplacement=T,caption=Communicating between controllers, label=lst:platoon]
request :: Double -> Message
request dist = 
  if dist < 3 then "faster" else ""

adjustSpeed :: (Communications, Double) -> Double
adjustSpeed (comms, oldSpeed) =
  if any (map (== "faster") comms)
    then s + 10 else s
\end{lstlisting}

We allow all vehicles in the simulation to communicate irrespective of distance and with zero packet loss.
However, users are free to implement and simulate unreliable communications, or distance constraints.  
%Thereby, due to the purity and modularity of FRP, new extensions are guaranteed to keep the existing code base intact.
