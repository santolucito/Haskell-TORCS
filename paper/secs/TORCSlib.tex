\section{\ourLib}

We developed a library to program controllers for autonomous vehicles using FRP, and connecting their controllers to the TORCS vehicle simulator.
This library, \mbox{\ourLib}, uses Yampa as the core FRP library, though its structure can easily be adapted to any other Haskell FRP library.

\subsection{Basics}

To interface with \ourLib, a user implements a controller that processes all data available from the sensors given via \texttt{CarState}. 
Next, he or she outputs commands to the vehicle using \texttt{DriveState}.
Both structures represent \textit{signal function} in FRP.
The core functionality of \ourLib is captured in the function \texttt{startDriver}, which launches the controller inside the simulator.
The \texttt{startDriver} function automatically connects a \texttt{Driver} to TORCS, which resolves to the right continuous \texttt{IO} actions.

\vspace{0.2em}
\begin{lstlisting}
  type Driver = SF CarState DriveState
  startDriver :: Driver -> IO ()
\end{lstlisting}
\vspace{0.2em}

\noindent The sensor and output data structures contain all the typical data available in an autonomously controlled vehicle.
\texttt{CarState} includes fields like \texttt{rpm} to monitor the engine, or \texttt{track} to simulate an array of LiDAR sensors oriented to the front of the vehicle.
\texttt{DriveState} includes fields like \texttt{accel} to control gas pedal, or \texttt{steering} to control the angle of the steering wheel.
A full description of the interface is available in the Simulated Car Racing Competition Manual~\cite{SCRCManual}. 

\subsection{Case Study : Driving}

As a demonstration of the \ourLib library in use, we present a case study on a simple controller for a car on an empty race track.
We implement the controller in FRP using Yampa, as shown in Listing~\ref{lst:driver}. 
It is connected to TORCS using our library, \ourLib.
The code is complete and immediately executable as-is together with an installation of TORCS.
Our controller successfully navigates, with some speed and finesse, a vehicle in track, as shown in Fig.~\ref{fig:race}.
The controller uses \texttt{ArrowLoop} to keep track of the current gear of the car.
Although the gear is available as sensor data, it is illustrative to keep track locally of this state.
In general, the \texttt{ArrowLoop} can be used to maintain any state that may be of interest in a future processing step.
Additionally, notice all of the data manipulation functions are pure, and lifted via the predefined function~\texttt{arr}.
One major advantage of FRP is this separation of dependency flow and data level manipulation. 

This abstraction makes it possible to easily reason about each of the components without worrying about confounding factors from the other.
For example, if a programmer wants to verify that the steering control is correct, it is semantically guaranteed that the only function that must be checked is \texttt{steering}.
Because of Haskell's purity, this is the only place where the steering value may be changed. This significantly reducing the complexity of verification or bug tracking in case of an error.

\begin{lstlisting}[float,floatplacement=TR,caption=A complete basic controller in Yampa, label=lst:driver]
{-# LANGUAGE Arrows, MultiWayIf, RecordWildCards #-}
module TORCS.Example where
import TORCS.Connect
import TORCS.Types

main = startDriver myDriver

myDriver :: Driver
myDriver = proc CarState{..}  -> do
  rec 
    oldG <- iPre 0 -< g
    g <- arr shifting -< (rpm, oldG)
    s <- arr steering -< (angle, trackPos)
    a <- arr gas -< (speedX, s)
  returnA -< defaultDriveState {accel = a, gear = g, steer = s}

shifting :: (Double, Int) -> Int
shifting (rpm, g) = if 
  | rpm > 6000 -> min 6 (g + 1)
  | rpm < 2000 -> max 1 (g - 1)
  | otherwise  -> g
 
steering :: (Double, Double) -> Double
steering (spd, trackPos) = let
  turns = spd * 14 / pi
  centering = turns - (trackPos * 0.1)
  clip x = max (-1) (min x 1)
 in
  clip centering

gas :: (Double, Double) -> Double
gas (speed, steer) = 
  if speed < (100 - (steer * 50)) then 1 else 0
\end{lstlisting}
% removed "targetspeed=100" and replaced it directly by the value. 
% There is no need here to spend this extra line.

\subsection{Multi-Vehicle Communication}

Thanks to functional language's exceptional support for parallelism, controlling multiple vehicles in a multi-threaded environment is exceedingly simple. 
In our library API, the user simply uses \texttt{startDrivers} rather than \texttt{startDriver}, and passes a list of \texttt{Driver} signal functions ``driving'' together.
By that, we easily let race various implementations against each other, or build a vehicle platooning controller.
In the latter, the user can even extend the implementation to simulate communication between the vehicles.

Our library already provides a simple interface for simulating communication between vehicles.
In order to broadcast a message to the other vehicles in the simulation, the controller simply broadcasts a message via the \texttt{broadcast} field of \texttt{DriveState}.
That message is then broadcast to all other vehicles as soon as possible, and received in the \texttt{communication} field of the input \texttt{CarState}.
Users now are able to implement small functions, similar to as in Listing~\ref{lst:platoon}. They then check if anyone has requested for the platoon to go faster.

\begin{lstlisting}[float,floatplacement=T,caption=Communicating between controllers, label=lst:platoon]
adjustSpeed :: (Communications, Double) -> Double
adjustSpeed (comms, oldSpeed) =
  if any (map (== "faster")) cs then s + 10 else s
\end{lstlisting}

We allow all vehicles in the simulation to communicate irrespective of
distance and with zero packet loss.  However, users may feel free to
implement and simulate unreliable communications, or distance
constraints.  Thereby, due to the purity and modularity of FRP, new
extensions are guaranteed to keep the existing code base intact.
