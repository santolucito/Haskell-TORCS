\section{FRP}

What is FRP

A driver observes the environment and changes the drive state over time.
This is represented as a \textit{signal function (SF)} in Yampa.

\begin{lstlisting}
type Driver = SF (Event CarState) DriveState
\end{lstlisting}

We then can create a driver, where the functions for shifting, steering, and accelerating are provided elsewhere in the code base.

\begin{lstlisting}
myDriver :: Driver
myDriver = proc e -> do
  CarState{..} <- arr getE -< e
  g <- arr shifting -< speedX
  s <- arr steering -< (angle,trackPos)
  a <- arr gas -< (speedX,s)
  returnA -< defaultDriveState {accel = a, gear = g, steer = s}
\end{lstlisting}

One major advantage of FRP is separation of control flow and data level manipulation. 
This abstraction makes it possible to easily reason about each of the components without worrying about confounding factors from the other.
For example, the user may only be concerned with verifying that their steering control is correct.
The user then only needs to verify the \texttt{steering} function in isolation from all other code.
This is a pure function, as evidenced by the type signature, which produces a new steering value based on the angle relative to the edges of the track and position on the track (where 0 is centered between the edges, and 1 is the left wall).

\begin{lstlisting}
targetSpeed = 100

shifting :: Double -> Int
shifting s = if 
  | s > 170 -> 6
  | s > 140 -> 5
  | s > 110 -> 4
  | s > 80 -> 3
  | s > 50 -> 2
  | s <= 50 -> 1
 
steering :: (Double,Double) -> Double
steering (spd,trackPos) = let
  turns = spd*14 / pi
  centering = turns - (trackPos*0.1)
  clip x = max (-1) (min x 1)
 in
  clip centering
  
gas :: (Double,Double) -> Double
gas (speed,steer) = 
  if speed < (targetSpeed-(steer*50)) then 0.5 else 0
\end{lstlisting}

