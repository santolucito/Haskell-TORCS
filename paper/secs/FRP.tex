\section{FRP}

\subsection{Preliminaries}

One of the classic approaches to build reactive systems is to use a call-back framework, that can be embedded inside a loop.
The call-back can be used to query the state of value, or to change that value.
With FRP, we instead introduce an abstractions of time that allow the programmer to directly manipulate some time-varying value.
This key abstraction is called a \textit{signal}, and has the following type:

\begin{lstlisting}
type Signal a = Time -> a
\end{lstlisting}

A signal is then a function that relates time to some value.
For example, the type \texttt{Signal Image} would then be video data, and \texttt{Signal Steer} would be the way a steering wheel is operated over time.
With signals, FRP also introduces the abstraction of a \textit{signal function (SF)}.
This is a transformer from one signal to another.

\begin{lstlisting}
type SF a b = Signal a -> Signal b
\end{lstlisting}

Using the previous signals, we can then introduce a type for a steering function that operates based on a video stream as \texttt{turn :: SF Image Steer}.
This function will process video and use it to decide how to steer.
We omit an implementation, as the details of the data transformation are not relevant to the structure of the FRP code.

There are many types of FRP based on different abstractions.
The monad abstraction can be used to handle signal processing~\cite{van2014monadic},
 but we will instead choose to focus on a FRP library, Yampa, that uses the arrow abstraction~\cite{hudak2003arrows}, so called Arrowized FRP.
Arrow generally run faster with little need for manual optimization~\cite{yallop2016causal}, but are fundamentally less expressive than a monadic FRP~\cite{lindley2011idioms}.
This can be beneficial because the more restrictive our languages, the less likely it is for a programmer to make a mistake.
As we will see in the sequel, Yampa is still powerful enough to write a controller to drive an autonomous vehicle.
At the same time, the style is also syntactically clear accessible to make for an easy introduction to the FRP paradigm.

In Arrowized FRP, Haskell provides an special syntax.
This is a composition environment, in which the programmer only manages the composition of arrow functions.
Inputs are read in from the right hand side, and piped to the left hand side.
This is demonstrated in Listing~\ref{lst:arrows}.

\begin{lstlisting}[float,floatplacement=h!,caption=Basic Arrowized FRP syntax,label=lst:arrows]
myDriver :: SF Image Steer
myDriver = proc image -> do
  basicSteer    <-     turn  -< image
  adjustedSteer <- arr avoid -< (image,basicSteer)
  returnA -< adjustedSteer
\end{lstlisting}

In this example, we introduce \texttt{avoid :: (Image,Steer) -> Steer}, a new function that will adjust our basic steering plan based on the image to avoid any obstacles.
In the above example, this function is lifted to the signal level using \texttt{arr :: (a -> b) -> SF a b}.
Since \texttt{turn} was already on the signal level, we did not need to apply the lifting function.

We can also imagine that our function to avoid obstacles requires two images to calculate the adjusted steering command.
This might be to filter noise in the image, or to calculate the velocity of an approaching obstacle.
In this case, we will need to save the previous state of the image for the next processing turn.
This can be achieved by using an ArrowLoop instance with the \texttt{rec} keyword.
Eliding the technical details for the purposes of this presentation, the syntax looks as shown in Listing~\ref{lst:loop}.

\begin{lstlisting}[float,caption=Using ArrowLoop to send feedback,label=lst:loop]
myDriver :: SF Image Steer
myDriver = proc image -> do
  rec
    oldI          <- iPre null -< image
    basicSteer    <-     turn  -< image
    adjustedSteer <- arr avoid -< (image,oldI,basicSteer)
  returnA -< adjustedSteer
\end{lstlisting}

The function \texttt{iPre} will take some initial state, in this case a null image, and save images for one time step each time it is processed.
This creates a type of feedback loop that is then used in the updated \texttt{avoid} function.
The \texttt{rec} keyword is used to denote a section of arrow code that has a mutual dependency.
Without the keyword, there would be an unresolvable dependency loop in the code.




\subsection{Case Study : Driving}

As a demonstration of our library in use, we present a case study on a controller for a car on an empty race track.
We implement a controller in FRP using Yampa, as shown in Listing~\ref{lst:driver}, that can be connected to TORCS using our library, \ourLib.
This code is complete and can be run as-is with an installation of TORCS.
This controller can successfully, and with some speed and finesse, navigate a vehicle in track shown in Fig.~\ref{fig:race}.

In order to connect to the library, the top level function must have type \texttt{Driver}, a type synonym for a signal function that process sensor data and makes driving decisions.

\begin{lstlisting}
type Driver = SF CarState DriveState
\end{lstlisting}

Our controller uses ArrowLoop to keep track of the current gear of the car.
Although the gear is available as sensor data, it is illustrative to keep track locally of this state.
Additioanlly, all of the data manipulation functions are pure, and lifted via \texttt{arr}.
One major advantage of FRP this separation of dependency flow and data level manipulation. 

This abstraction makes it possible to easily reason about each of the components without worrying about confounding factors from the other.
For example, if a programmer wants to verify that the steering control is correct, it is semantically guaranteed that the only function that must be checked is \texttt{steering}.
Because of Haskell's purity, this is the only place where the steering value may be changed, significantly reducing the size of the verification problem.

\begin{lstlisting}[float,floatplacement=TR,caption=A complete basic controller in Yampa, label=lst:driver]
{-# LANGUAGE Arrows,
             MultiWayIf,
             RecordWildCards #-}
module TORCS.Example where
import TORCS.Connect
import TORCS.Types

main = startDriver myDriver

myDriver :: Driver
myDriver = proc CarState{..}  -> do
  rec 
    oldG <- iPre 0 -< g
    g <- arr shifting -< (rpm,oldG)
    s <- arr steering -< (angle,trackPos)
    a <- arr gas -< (speedX,s)
  returnA -< defaultDriveState {accel = a, gear = g, steer = s}

shifting :: (Double,Int) -> Int
shifting (rpm,g) = if 
  | rpm > 6000 -> min 6 (g+1)
  | rpm < 2000 -> max 1 (g-1)
  | otherwise  -> g
 
steering :: (Double,Double) -> Double
steering (spd,trackPos) = let
  turns = spd*14 / pi
  centering = turns - (trackPos*0.1)
  clip x = max (-1) (min x 1)
 in
  clip centering
  
targetSpeed = 100
gas :: (Double,Double) -> Double
gas (speed,steer) = 
  if speed < (targetSpeed-(steer*50)) then 1 else 0
\end{lstlisting}
%\end{minipage}

